QUE1:多态是：父类的引用指向子类的对象 --》 Person p = new Man();
理解：为了减少对象为方法形参的方法重载
SO1：是否可以：Man m = new Person(); 即子类的引用指向父类的对象
1.强制类型转换（向下转型）

QUE2：重载为静态绑定，多态为晚绑定。
即内存再调用重载方法时对于不同参数类型的重载方法进行了区分，为静态绑定 ;
而多态则为在内存调用时才知道要调用的对象，为晚绑定 ;

QUE3：多态 未调用的 父类方法 称为：虚拟方法 ;
           调用的  子类方法 称为：

QUE4: 多态对于对象是：编译看左边，运行看右边 ;
      多态对于属性是：编译看右边，运行看左边（属性没有多态） ;

QUE5: 重写：（非 static 的方法）
1.方法名、形参列表相同
2.权限修饰符：子类 >= 父类
3.返回值：
  a.void：子类 == 父类 == void
  b.基本数据类型：子类（基本数据类型） == 父类（基本数据类型） == 相同类型
  c.引用数据类型：子类 == 父类 || 子类 == 父类使用数据类型的子类
  d.异常：子类抛出的的异常 <= 父类抛出的异常

QUE6：
this(形参列表)：本类重载的其它的构造器 --> n 个构造器至多有 n-1 个构造器使用 this()
super(形参列表):调用父类中指定的构造器 --> n 个构造器至少有一个构造器使用 super()

QUE7：子类对象实例化：一定会调用其所有父类的构造器